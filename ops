{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":5,"timestamp":1711391211,"nonce":"FWaTZnycpFhdh0PoZXuNr97t/7w=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALZfcLE"},"added":["status: confirmed bug"],"removed":[]},{"type":5,"timestamp":1711391211,"nonce":"o2A3/u1VJX1Re9y1mNXGOVCvE/w=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALZfcLK"},"added":["part: derivation"],"removed":[]},{"type":5,"timestamp":1711391211,"nonce":"Kgr4o7PddRZGdgZzJ2/J43WwmPA=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALZfcLZ"},"added":["issue: distribution"],"removed":[]},{"type":5,"timestamp":1711391211,"nonce":"Kxposf5C71EGPXLtnMdLPCL/FIk=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALZfcLi"},"added":["derive: least-effort"],"removed":[]},{"type":5,"timestamp":1711391211,"nonce":"Bh72nU19kVKvyFCK5V1mNAMGVo8=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALZfcLq"},"added":["part: examples"],"removed":[]},{"type":3,"timestamp":1711467421,"nonce":"d8mxJTx+hYVjiQqdF0ORmiljspk=","metadata":{"github-id":"IC_kwDOEt7lWM54cnl3","github-url":"https://github.com/buzden/deptycheck/issues/128#issuecomment-2020768119"},"message":"The reason for such behaviour is the following. Data definitions are the following (ignoring forward declarations):\n\n```idris\ndata SortedList : Type where\n  Nil  : SortedList\n  (::) : (x : Nat) -\u003e (xs : SortedList) -\u003e FirstGT x xs =\u003e SortedList\n\ndata FirstGT : Nat -\u003e SortedList -\u003e Type where\n  E  : FirstGT n []\n  NE : x `GT` n -\u003e FirstGT n $ (x::xs) @{prf}\n```\n\nBy definition of `(::)` and dependencies in it, we can see that the parameter `xs` would be generated by the parameter of type `FirstGT x xs` in a dependent pair. So, actual recursive `xs` would be generated not by generator of `SortedList`, but by `FirstGT`. But `FirstGT` is not a recursive data type, so its constructors would be distributed evenly, so the original argument `xs` of `(::)` would get empty and non-empty lists with equal probability. Thus, we get usually lists of length 1 or 2, and sometimes 0 or 3.","files":null},{"type":3,"timestamp":1711467794,"nonce":"TyyqLAYgzldq6g4JkytXKCjESps=","metadata":{"github-id":"IC_kwDOEt7lWM54csHj","github-url":"https://github.com/buzden/deptycheck/issues/128#issuecomment-2020786659"},"message":"One possible solution for this would be tuning frequences not only for recursive constructors, but for constructors that are *potentially* indexed by self-recursive constructors, in case when these indices are generated, not given.\n\nPotentially indexed means the following: if we have a data type, say,\n\n```idris\ndata Indexed : SortedList -\u003e Type where\n  Zero : Indexed []\n  Many : Indexed (x::xs)\n  Any : Indexed xs\n```\nthen in the generator `Gen MaybeEmpty (xs ** Indexed xs)` only `Zero` constructor would have frequency `1`, **both** other constructors must have frequency proportional to left fuel, since `Any` may also have recursive constructor as an index.\n\n---\n\nAnyway, this idea needs a good thought, and I'm not sure this is a correct way to proceed.","files":null},{"type":3,"timestamp":1711564028,"nonce":"4/Ryk0QLITBo028tE1UxFKVhW/c=","metadata":{"github-id":"IC_kwDOEt7lWM54nTrP","github-url":"https://github.com/buzden/deptycheck/issues/128#issuecomment-2023570127"},"message":"Two more thoughts:\n\n1) It seems that this problem is mostly relevant when *the simplification hack* #96 is used\n\n2) it's unclear what to do if the index is of form, say, `MkX (MkY y) (MkZ z)` with different combinations of direct recursiveness status of `MkX`, `MkY` and `MkZ`. I'm assuming now that a disjunction of all involved constructors in the index expression is enough to trigger `leftDepth` weight for `frequency`.","files":null},{"type":5,"timestamp":1711638578,"nonce":"GLx5TWWI3UkxcijBgmYtQWUh3wQ=","metadata":{"github-id":"UNLE_lADOEt7lWM6DgxvZzwAAAALcItxe"},"added":[],"removed":["derive: least-effort"]},{"type":5,"timestamp":1711638578,"nonce":"QD3nbDyvhi9jYYBymaUJzFgYNKk=","metadata":{"github-id":"LE_lADOEt7lWM6DgxvZzwAAAALcItxq"},"added":["derive: core"],"removed":[]},{"type":3,"timestamp":1711718092,"nonce":"J0ef3g27cEqtA6KVziRXNOv3Ctg=","metadata":{"github-id":"IC_kwDOEt7lWM541RsM","github-url":"https://github.com/buzden/deptycheck/issues/128#issuecomment-2027232012"},"message":"The current modification of the criteria is the following. Consider all the names in all generated indices of the constructor-under-the-question (1). Those names are either constructor's arguments (2), or some external names (3). If any external name (2) is a recursive constructor or a non-constructor, then we consider the whole original constructor (1) to be potentially recursively-indexed. If not, then consider types of all mentioned as (2), and look if **their types** are recursive or not. If yes, then consider the constructor (1) to be potentitally recursively-indexed. If both checks are false, consider it as a non-recursive constructor.","files":null},{"type":6,"timestamp":1711719663,"nonce":"GAU+tSAS1EkTivvCmxoyUpB3jn4=","metadata":{"github-id":"UCE_lALOEt7lWM541RsMzkMmlG4"},"target":"14e941550fa117371f60b3b4def33b5b776ba469fab4201be069fe2d708d74d2","message":"The current modification of the criteria is the following. Consider all the names in all generated indices of the constructor-under-the-question (1). Those names are either constructor's arguments (2), or some external names (3). If any external name (2) is a recursive constructor or a non-constructor, then we consider the whole original constructor (1) to be potentially recursively-indexed. If not, then consider types of all mentioned as (2), and look if **their types** are recursive or not. If yes, then consider the constructor (1) to be potentitally recursively-indexed. If both checks are false, consider it as a non-recursive constructor.\n\nEDIT: no, this idea is wrong. For example, using this we'll get equal probabilities for both constructors of `Fin`, which is not good.\n\nI was trying to formulate universal criteria covering cases like\n```idris\ndata Prop : List X -\u003e Type where\n  P1 : Prop [] -- non-recursive \n  P2 : Prop (x::xs) -- indexed by recursive\n  P3 : Prop xs -- indexed by potentially recursive\n  P4 : Prop (externalFun x) -- indexed by potentially recursive\n  P5 : (f : Y -\u003e List X) -\u003e (x : Y) -\u003e Prop (f x) -- indexed by potentially recursive\n```","files":null},{"type":3,"timestamp":1712147381,"nonce":"RUqHciIEHdz8wTMmhE4oumqpCjk=","metadata":{"github-id":"IC_kwDOEt7lWM55Q6UU","github-url":"https://github.com/buzden/deptycheck/issues/128#issuecomment-2034476308"},"message":"The latest thought was that we should first clear the common application prefix of index expressions, so that, say, `S` in indices of `Fin` wouldn't count. I even implemented it in the commit 5bf57cabc9ffc115450e2914e2fbccefd5bc6413 but it doesn't seem to work properly, because it starts to count `X2` as recursively indexed in types like\n```idris\ndata X : Nat -\u003e Type where\n  X1 : X 1\n  X2 : X 2\n```\n\nsince the index has expressions `S Z` and `S (S Z)`. Removing the prefix leads to `Z` and `S Z` respectively, after which `S` in `X2` selects high weight. In practise it make some distributions worse than before.\n\n---\n\nNow, I'm feeling like a blind rat searching for an exit in a maze....\n\n---\n\nMore suprisingly, I realised that my original explanation of bad distribution in the `sorted-list` example is wrong, because `FirstGT`'s constructor `NE` is honestly recursive, thanks to the `prf` argument. It means, that I was wrong about the reason of observed bad distribution.","files":null},{"type":4,"timestamp":1744632222,"nonce":"m7kQxLBriPVPaX5Dm1GSX6oKZTg=","metadata":{"github-id":"CE_lADOEt7lWM6DgxvZzwAAAAQECzCa"},"status":2}]}