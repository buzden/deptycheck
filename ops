{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":6,"timestamp":1690301947,"nonce":"cuwkrXL+f755e1RcRkj/RKlEoEI=","metadata":{"github-id":"UCE_lAHOEt7lWM5shXaSzkakO6Y"},"target":"ec9e3e7346003d52802004a0c5adb8175e213e86edcfcf19ea62058e85c54125","message":"It would be good to collect some information about *model coverage*, i.e. coverage in terms of the original data type (for derived generators) and/or coverage in terms of alternatives inside a generator.\n\nThe topic is not univocal, there are definitely a ton of ways how such coverage can be gained and how can it be represented. We'd like to increase slowly starting from collecting just which types and type families were present during a series of generation disregarding the position of this generation, say, in recursion; then we can continue with adding information about which particular constructors were actually used in generation in particular types or type families, again disregarding the position. Then, we can further refine this, say, by considering the position in the generation tree, or by considering coverage of constructors separately for different values of indices for indexed type families.\n\nFor the first two steps, there are at least the following steps to be done:\n\n- [ ] We need an elaboration script being given a data type family name, showing the list of all data type families that are used inside. This is needed to list all possible items of a coverage of type families (and their constructors).\n- [ ] A data structure indexed by a generation tree (i.e., a generator), which shows which alternative was used to generate this or that data value. This data structure would be returned by an alternative variant of `unGen`. Having additionally description values of `oneOf`s, using this indexed data structure, we can at least know which data type families were tried to generate a value.\n- [ ] Then, we can extend descriptions of `oneOf`s to contain particular information about particular constructors. It would allow us to evaluate model coverage more precisely. This all, of course, applied only to derived generators, and to generators, whose authors added descriptions corresponding to the derived ones.\n- [ ] Maybe, we need some structure on the descriptions, i.e. descriptions would be not just `Maybe String`, but some our custom `FromString` type, which may contain type itself, and, possibly, a `Vect` of subdescriptions for each alternative.\n- [ ] Maybe, we could invent some kind of a `%macro`, which can fill appropriate description of a hand-written generators.","files":null},{"type":6,"timestamp":1694010225,"nonce":"ODzhrzy/cPSlXmjzSRvRkwCb9n8=","metadata":{"github-id":"UCE_lAHOEt7lWM5shXaSzkl-dNo"},"target":"ec9e3e7346003d52802004a0c5adb8175e213e86edcfcf19ea62058e85c54125","message":"It would be good to collect some information about *model coverage*, i.e. coverage in terms of the original data type (for derived generators) and/or coverage in terms of alternatives inside a generator.\n\nThe topic is not univocal, there are definitely a ton of ways how such coverage can be gained and how can it be represented. We'd like to increase slowly starting from collecting just which types and type families were present during a series of generation disregarding the position of this generation, say, in recursion; then we can continue with adding information about which particular constructors were actually used in generation in particular types or type families, again disregarding the position. Then, we can further refine this, say, by considering the position in the generation tree, or by considering coverage of constructors separately for different values of indices for indexed type families.\n\nFor the first two steps, there are at least the following steps to be done:\n\n- [x] We need an elaboration script being given a data type family name, showing the list of all data type families that are used inside. This is needed to list all possible items of a coverage of type families (and their constructors).\n- [ ] A data structure indexed by a generation tree (i.e., a generator), which shows which alternative was used to generate this or that data value. This data structure would be returned by an alternative variant of `unGen`. Having additionally description values of `oneOf`s, using this indexed data structure, we can at least know which data type families were tried to generate a value.\n- [ ] Then, we can extend descriptions of `oneOf`s to contain particular information about particular constructors. It would allow us to evaluate model coverage more precisely. This all, of course, applied only to derived generators, and to generators, whose authors added descriptions corresponding to the derived ones.\n- [ ] Maybe, we need some structure on the descriptions, i.e. descriptions would be not just `Maybe String`, but some our custom `FromString` type, which may contain type itself, and, possibly, a `Vect` of subdescriptions for each alternative.\n- [ ] Maybe, we could invent some kind of a `%macro`, which can fill appropriate description of a hand-written generators.","files":null},{"type":6,"timestamp":1698491791,"nonce":"I7H40jQc2VrxXbPb9YJwHE19I64=","metadata":{"github-id":"UCE_lAHOEt7lWM5shXaSzk0H7IE"},"target":"ec9e3e7346003d52802004a0c5adb8175e213e86edcfcf19ea62058e85c54125","message":"It would be good to collect some information about *model coverage*, i.e. coverage in terms of the original data type (for derived generators) and/or coverage in terms of alternatives inside a generator.\n\nThe topic is not univocal, there are definitely a ton of ways how such coverage can be gained and how can it be represented. We'd like to increase slowly starting from collecting just which types and type families were present during a series of generation disregarding the position of this generation, say, in recursion; then we can continue with adding information about which particular constructors were actually used in generation in particular types or type families, again disregarding the position. Then, we can further refine this, say, by considering the position in the generation tree, or by considering coverage of constructors separately for different values of indices for indexed type families.\n\nFor the first two steps, there are at least the following steps to be done:\n\n- [x] We need an elaboration script being given a data type family name, showing the list of all data type families that are used inside. This is needed to list all possible items of a coverage of type families (and their constructors).\n- [ ] A data structure indexed by a generation tree (i.e., a generator), which shows which alternative was used to generate this or that data value. This data structure would be returned by an alternative variant of `unGen`. Having additionally description values of `oneOf`s, using this indexed data structure, we can at least know which data type families were tried to generate a value.\n- [ ] Then, we can extend descriptions of `oneOf`s to contain particular information about particular constructors. It would allow us to evaluate model coverage more precisely. This all, of course, applied only to derived generators, and to generators, whose authors added descriptions corresponding to the derived ones.\n- [ ] Maybe, we need some structure on the descriptions, i.e. descriptions would be not just `Maybe String`, but some our custom `FromString` type, which may contain type itself, and, possibly, a `Vect` of subdescriptions for each alternative.\n- [x] Maybe, we could invent some kind of a `%macro`, which can fill appropriate description of a hand-written generators.","files":null},{"type":5,"timestamp":1690301922,"nonce":"+kWn/9KgADxeWp1pQG+pw8PRBTQ=","metadata":{"github-id":"LE_lADOEt7lWM5shXaSzwAAAAJO6tty"},"added":["code: enhancement"],"removed":[]},{"type":5,"timestamp":1690301922,"nonce":"154Gq9iGhTVbHPF4zrs/gUSSrzE=","metadata":{"github-id":"LE_lADOEt7lWM5shXaSzwAAAAJO6tt2"},"added":["part: generators"],"removed":[]},{"type":5,"timestamp":1690301922,"nonce":"9WewpfbVvO+6ij2WF5cX4wFyZOk=","metadata":{"github-id":"LE_lADOEt7lWM5shXaSzwAAAAJO6tt9"},"added":["status: feature request"],"removed":[]},{"type":3,"timestamp":1691480149,"nonce":"sVFxfpxXGs9z8Cvt+zDNdC/YfuE=","metadata":{"github-id":"IC_kwDOEt7lWM5jfAjn","github-url":"https://github.com/buzden/deptycheck/issues/78#issuecomment-1669073127"},"message":"Another idea to support collection of information needed for model coverage is to add special operations (and thus, constructors for the `Gen` type) for logging, namely two of them:\n- logging of a point, intended to be used with the `\u003e\u003e=` operation (this needs changing the type of the `Bind` generator);\n- logging of a bracket, i.e. marking the whole subgenerator; this allows to mark special positions, say, in a product.\n\nThe latter one seems to be more useful. Say, it is able to catch lots of stages of metric's refinement: types-only, types+constructors, types+constructors at constructor's positions. For example, when we have\n\n```idris\ndata Gen : ... -\u003e Type where\n  ...\n  Log : LogType -\u003e (subgen : Gen ...) -\u003e Gen ... \n  ...\n```\n\nand a data type `X`\n\n```idris\ndata X : Type where\n  A : Nat -\u003e X -\u003e X -\u003e X\n  B : Nat -\u003e X\n```\n\n(for some `LogType`, I don't know what can it be yet) we can define a generator during derivation in the following way:\n\n```idris\ngenX : Gen ... X\ngenX_A : Gen ... X\ngenX_B : Gen ... X\n\ngenX_A = log (constructor \"A\") [| A (log (constrPos 0) genNat) (log (constPos 1) genX) (log (constPos 2) genX) |]\ngenX_B = log (constructor \"B\") [| B (log (constrPos 0) genNat) |]\n\ngenX = log (type \"X\") $ oneOf\n  [ genX_A\n  , genX_B\n  ]\n```\n\n**However**, there is a problem in definition of, say, `\u003c*\u003e` for `Log` constructor on the both sides, since if we do our usual simplification trick, say, putting all `Log`s out, we will lose cool property for precise logging of the constructor position.\n\nShortly speaking, I don't know how can `Applicative` be implemented with the `Log` constructor like above, which preserves all needed properties for nice logging.","files":null},{"type":3,"timestamp":1691936317,"nonce":"SYip9IaZ4es4wcyflqpVPft0tpc=","metadata":{"github-id":"IC_kwDOEt7lWM5j62-P","github-url":"https://github.com/buzden/deptycheck/issues/78#issuecomment-1676373903"},"message":"Even the `Log` constructor seems to be redundant.\n\nConsider having `List LogType` (whatever `LogType` is, as above) only being added to the `Pure` and `Raw` constructors. Then, `log` function may add it directly to the `Pure` and `Raw`, ignore it when `Empty` (however, it can be added even there; but in lots places everything have to be rewritten to not to lose such log messages; still, I don't see any reason for doing this), propagating this `log` down to alternatives of `OneOf` and to the LHS of the `Bind`.\n\nI'm not sure about `Bind`, because `log ?whatever (rawGen \u003e\u003e= cont)` seems to tell about the whole bind, i.e., it should not be equivalent to `log ?whatever rawGen \u003e\u003e= cont`. This can be solved by storing the same `List LogType` in the `Bind` constructor itself.\n\nAnyway, I'm not sure it's possible to build a correct **tree** during `unGen` when data it stored in this way (without having a separate node for an applicative composition).\n\n---\n\nSurely, we could store `Maybe LogType` in every node, but this smells strongly with higher-kinded data, and should be done properly and generally.","files":null},{"type":5,"timestamp":1694010136,"nonce":"aWulJnVDitTjE42GzZj9S2BDLPg=","metadata":{"github-id":"LE_lADOEt7lWM5shXaSzwAAAAJluqld"},"added":["part: model coverage"],"removed":[]},{"type":3,"timestamp":1754567227,"nonce":"sg9cYPc6f4ltFmlyqtpAYnjiPuM=","metadata":{"github-id":"IC_kwDOEt7lWM68k-mI","github-url":"https://github.com/buzden/deptycheck/issues/78#issuecomment-3163810184"},"message":"Done in #130 and #159","files":null},{"type":4,"timestamp":1754567227,"nonce":"D+DB8RVQ+nkztTxNw5Jxvg8W+Cg=","metadata":{"github-id":"CE_lADOEt7lWM5shXaSzwAAAARufqrM"},"status":2}]}