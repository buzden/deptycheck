{"author":{"id":"3af9e2655ad9f293988512be60886dcee65d101213a8f77d6e1aec75c05cdd9f"},"ops":[{"type":1,"timestamp":1705871357,"nonce":"hy8mtyo0nlyWuGmd6+qe2QS5mQA=","metadata":{"github-id":"I_kwDOEt7lWM58vSjV","github-url":"https://github.com/buzden/deptycheck/issues/109","origin":"github"},"title":"Manual fine-tuning of generator ordering","message":"Ordering of subgenerators seems to have a great effect on the performance of generators. Part of these concerns are going to be addressed by applicative composition of generators described in https://github.com/buzden/deptycheck/issues/81. This would eliminate the need to choose orderings of independent generators, reducing the space of possible orderings.\n\nSometimes, when deriving a generator, a value that occurs in indices of several arguments of a data constructor must be produced. In that case, there is a choice -- we need to pick an argument that will be generated together with a value, and the rest of the arguments will get that value as a given index. This choice could greatly influence the performance of resulting generator.\n\n## Problematic case\n\nTo make an illustrated example, let's consider a simple language. It shall consist of a sequence of assigning arithmetic expressions to variables. Already declared variables can be used in following expressions. A simple program of this language would look like this:\n\n```\nx2 = 2 * 5 + 7\nx1 = x2 * 4\nx3 = x1 - 3\n```\n\nThe language specification will follow the following scheme (full implementation is [here](https://github.com/AlgebraicWolf/den/tree/main/idris/deptycheck/gen-orderings)):\n\n```idris\ndata Expression : Context -\u003e Type where\n  ...\n\ndata Lang : Context -\u003e Type where\n  Empty : Lang []\n  Assign : (nm : Name) -\u003e (expr : Expression ctx) -\u003e (rest : Lang ctx) -\u003e Lang (nm::ctx)\n```\n\nThen, if we want to produce the generator for `Lang[]`, we can choose one of two orderings for data constructor `Assign`:\n1. `Expression[]` and `Lang[0]` -- the one currently chosen by DepTyCheck,\n2. `Expression[0]` and `Lang[]`\n\nAs it turns out, the second ordering performs __significantly__ better. The number of constructors used in expressions depends linearly on the average time to generate a sample:\n\n![image](https://github.com/buzden/deptycheck/assets/36044777/d6727cd4-8366-4324-97f2-66032587b487)\n\nThe number of variables introduced shows dependency on time akin to logarithmic:\n\n![image](https://github.com/buzden/deptycheck/assets/36044777/608a35e8-6c53-47f9-b6c1-cb363fa56c0f)\n\nGeneration time increases exponentially w.r.t. the fuel provided:\n\n![image](https://github.com/buzden/deptycheck/assets/36044777/3bc149f4-f389-4b17-bc6c-070594512b06)\n\nI was not able to build similar plots for either derived or handwritten generator that would be structured like a derived one due to spurious slow downs in generation for fuel greater than 2: the generator would freeze after several examples for unreasonably long periods of time.\n\n## Possible solutions\n\nBecause of the dramatic difference in performance, it would be beneficial to give user control over the orderings of generators. One solution that I have in mind is to supply user with special type wrappers:\n\n```idris\npublic export\nGiven : List String -\u003e Type -\u003e Type\nGiven _ ty = ty\n\npublic export\nGenerated : List String -\u003e Type -\u003e Type\nGenerated _ ty = ty\n```\n\nUsing them, it is possible to manually choose arguments for which indices will be derived or generated:\n\n```idris\ndata Lang : Context -\u003e Type where\n  Empty : Lang []\n  Assign : (nm: Name) -\u003e (expr : Given [\"ctx\"] (Expression ctx)) -\u003e (rest : Generated [\"ctx\"] (Lang ctx)) -\u003e Lang (nm::ctx)\n```\n\nOr, alternatively\n\n```idris\npublic export\nGiven : a -\u003e a\nGiven x = x\n\npublic export\nGenerated : a -\u003e a\nGenerated x = x\n```\n\nThat will be used like this:\n\n```idris\ndata Lang : Context -\u003e Type where\n  Empty : Lang []\n  Assign : (nm: Name) -\u003e (expr : Expression (Given ctx)) -\u003e (rest : Lang (Generated ctx)) -\u003e Lang (nm::ctx)\n```\n\nWhichever one would be easier to work with.\nThese wrappers should be treated specially during derivation before normalising the constructor types. It should be optional for the user to provide the wrappers, and we must not require annotating all arguments -- derivation engine should start with what the user had specified and work out the rest.\n\nOf course, there are some caveats associated with this approach:\n- User-defined annotations might turn out to be nonsensical -- one might choose to annotate all occurrences of an index with `Given` modifier, or make several `Generated` occurrences. We need to choose how to handle such scenarios.\n- User might want to derive several generators with different signatures. In that case, the appropriate set of modifiers is likely to be different. Of course, this could be solved by creating several data types, and writing trivial conversion functions between them. However, this would lead to a great amount of boilerplate code and repetition.","files":null}]}