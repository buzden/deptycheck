{"author":{"id":"3af9e2655ad9f293988512be60886dcee65d101213a8f77d6e1aec75c05cdd9f"},"ops":[{"type":3,"timestamp":1660858761,"nonce":"sUmdHlzg9dP9zHDS2erhZiorU08=","metadata":{"github-id":"IC_kwDOEt7lWM5It5qf","github-url":"https://github.com/buzden/deptycheck/issues/20#issuecomment-1219992223"},"message":"Upon inspecting the derived generator, we can see that in has the following structure:\n```idris\ngenZ fuel_arg x x' = let genMkZ : Fuel -\u003e (x, x' : X) -\u003e Gen $ Z x x'\n                                      genMkZ cons_fuel (Cons x prf) (Cons to_be_deceqed_x0 to_be_deceqed_prf1) =\n                                        case decEq to_be_deceqed_prf1 prf of\n                                          (No _) =\u003e empty\n                                          (Yes elim_to_be_deceqed_prf1_prf) =\u003e rewrite elim_to_be_deceqed_prf1_prf in\n                                            case decEq to_be_deceqed_x0 x of { ... } \n                                      genMkZ _ _ _ = empty\n                                      in genMkZ fuel_arg x x'\n```\nHowever, upon performing `decEq to_be_deceqed_prf1 prf` the type of `to_be_deceqed_prf1` is `Y to_be_deceqed_x0` and the type of `prf` is `Y x`. It seems that the derived generator should perform `decEq to_be_deceqed_x0 x` and match on `Yes Refl`, and only then compare `to_be_deceqed_prf1` and `prf`","files":null}]}