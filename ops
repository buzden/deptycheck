{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":1,"timestamp":1679317513,"nonce":"J1chWgscFkWaH0P/auY+0Z4+yfc=","metadata":{"github-id":"I_kwDOEt7lWM5hR3Ur","github-url":"https://github.com/buzden/deptycheck/issues/55","origin":"github"},"title":"Automatic data types fusion when deriving generator for constructor","message":"This can be seen as generation-time optimisation by growing the size of derived code. @AlgebraicWolf tested fusion in an ad-hoc example and it gave better results. We can generalise this.\n\nThe idea is to generate a data type for each data constructor (which is of a (complex?) dependent type) which would contain all constraints of data types of all constructor parameters. When we generate arguments for this particular constructor, instead of a sequence of subgeneration calls and then assembling it to the constructor's call, we can simply generate that specialised data structure and use it to generate the constructor call.\n\n---\n\nFor example, consider couple of GADTs:\n```idris\ndata X : Nat -\u003e Type where\n  X1 : Double -\u003e X1\n  Xn : (n : Nat) -\u003e X (S n)\n\ndata Y : Nat -\u003e Type where\n  Y0 : String -\u003e Y 0\n  Y1 : Char -\u003e Y 1\n  Yn : Y n\n```\n\nIf we derive a generator for data type `Z` defined like\n```idris\ndata Z : Type where\n  Zx : Z\n  Zn : (n : Nat) -\u003e X n -\u003e Y n -\u003e Z\n```\n\nwe now make generator for `Z` to be alternatives of generator for `Zx` and generator for `Zn`, where generator of `Zn` is an alternative between approximately\n```idris\ndo (n ** xn) \u003c- genAnyX\n   yn \u003c- genY n\n   pure $ Zn n xn yn\n```\n\nand\n\n```idris\ndo (n ** yn) \u003c- genAnyY\n   xn \u003c- genX n\n   pure $ Zn n xn yn\n```\n\n---\n\nWhat is suggested here is to create a special data type\n\n```idris\ndata ForZn : Type where\n  ForZn_X1_Y1 : Double -\u003e Char -\u003e ForZn\n  ForZn_X1_Yn : Double -\u003e ForZn\n  ForZn_Xn_Y1 : Char -\u003e ForZn\n  ForZn_Xn_Yn : (n : Nat) -\u003e ForZn\n```\n\nwhich contains all possible data from all possible arguments of the constructor `Zn` in a fused way. So, there exists a function\n`zn : ForZn -\u003e Z` which produces all possible calls to constructor `Zn`:\n\n```idris\nzn : ForZn -\u003e Z\nzn $ ForZn_X1_Y1 d k = Zn $ 1 (X1 d) (Y1 k)\nzn $ ForZn_X1_Yn d   = Zn $ 1 (X1 d) Yn\nzn $ ForZn_Xn_Y1 c   = Zn $ 1 (Xn 0) (Y1 k)\nzn $ ForZn_Xn_Yn n   = Zn $ (S n) (Xn n) Yn\n```\n\nSo, generator for `Zn` can simply look like `zn \u003c$\u003e genForZn`, and generator for `ForZn` can be simply derived as usual (it does not contain dependent types in its constructors, so this mechanism should not be applied to it recursively).","files":null}]}