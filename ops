{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":6,"timestamp":1754569049,"nonce":"IHRI1jjLUKYET/WDYbnsVO4HLk8=","metadata":{"github-id":"UCE_lAHOEt7lWM7EtbHPzoRh5_Q"},"target":"b6d99f6730250640186b41b1e6d05b61871ef3139896115d479bfa98645be91b","message":"In theory we can have an interface(s) passed to `unGen` or to its alternative, running in a monad (like existing `CanManageLabels`) having information about\n- start of generation\n- successful and unsuccessful end of generation (unsuccessful, however, can be managed through `MonadError`, as now already)\n- most importantly,\n  - the current decision point (index of the chosen `oneof` node of a generator tree, and indices of all previous decisions, thus identifying uniquely full path to the current decision point)\n  - possibly, a decision that is going to be made (we'll need to modify `pickWeighted` for that slightly)\n  - possibly, all the labels met in the generator tree before the current point (but, this can be made with existing `CanManageLabels` in a stateful monad)\n  - ability to override the default decision with our own one (based, say, on the statistics or whatever)\n\nMaybe, we can generalise `unGen` by not requiring `MonadRandom`, but the default implementation of the proposed interface should require it, thus calls to `randomFin` and `pickWeighted` would be inside this default implementation. Then, statistics-based one would be a named implementation requring external similarly typed implementation, just adding the statistics-management functionality. This idea, however, requires changes in `RawGen` data type, since we will need not `MonadRandom`, but the proposed decision-making interface there, which whould make us unable to use simple `choose` unless this decision-making interface is a subinterface of `MonadRandom`, or at least it implies it somehow. Well, maybe, we can treat empty list of the current decisions as a stuff that can provide `MonadRandom`?\n\nThis all can be used for collecting and analysing current decisions and their influence on, say, SUT's coverage, thus implementing a coverage-guided adjustments. It can, say, find that particular decisions influence positively on, say, SUT's coverage and increase probability of these decisions. Alternatively, it can increase probabilities of never visited choices in order to achieve better diversity of generated samples and increase the model coverage. Finally, it can just analyse the other decision algorithm and print its statistics afterwards. Existing labelling mechanism can be handy for such reports.","files":null},{"type":6,"timestamp":1754569472,"nonce":"GpP3ddQGkc/4++tgV3iquByT8Z4=","metadata":{"github-id":"UCE_lAHOEt7lWM7EtbHPzoRiIMM"},"target":"b6d99f6730250640186b41b1e6d05b61871ef3139896115d479bfa98645be91b","message":"In theory we can have an interface(s) passed to `unGen` or to its alternative, running in a monad (like existing `CanManageLabels`) having information about\n- start of generation\n- successful and unsuccessful end of generation (unsuccessful, however, can be managed through `MonadError`, as now already)\n- most importantly,\n  - the current decision point (index of the chosen `oneof` node of a generator tree, and indices of all previous decisions, thus identifying uniquely full path to the current decision point)\n  - possibly, a decision that is going to be made (we'll need to modify `pickWeighted` for that slightly)\n  - possibly, all the labels met in the generator tree before the current point (but, this can be made with existing `CanManageLabels` in a stateful monad)\n  - ability to override the default decision with our own one (based, say, on the statistics or whatever)\n\nMaybe, we can generalise `unGen` by not requiring `MonadRandom`, but the default implementation of the proposed interface should require it, thus calls to `randomFin` and `pickWeighted` would be inside this default implementation. Then, statistics-based one would be a named implementation requring external similarly typed implementation, just adding the statistics-management functionality. This idea, however, requires changes in `RawGen` data type, since we will need not `MonadRandom`, but the proposed decision-making interface there, which whould make us unable to use simple `choose` unless this decision-making interface is a subinterface of `MonadRandom`, or at least it implies it somehow. Well, maybe, we can treat empty list of the current decisions as a stuff that can provide `MonadRandom`?\n\nThis all can be used for collecting and analysing current decisions and their influence on, say, SUT's coverage, thus implementing a coverage-guided adjustments. It can, say, find that particular decisions influence positively on, say, SUT's coverage and increase probability of these decisions. Alternatively, it can increase probabilities of never visited choices in order to achieve better diversity of generated samples and increase the model coverage. Finally, it can just analyse the other decision algorithm and print its statistics afterwards. Existing labelling mechanism can be handy for such reports.\n\nRoughtly speaking, this interface (or at least, the decision part) is meant to be something like this:\n```idris\ninterface Decision m where\n  choicePoint : (path : List Nat) -\u003e (altWeights : List Nat1) -\u003e m $ Fin altWeights.length\n```\nProbable problem is that (original) weights of alternatives is a constant for each `path`, thus it can be remembered inside `m`. It means that users of the interface must guarantee the same values of weights for each path, or weights should be returned in some other way (maybe, it should be an indexing function by the generator and path?). Maybe, we should use not a list of nats as a path, but a special data structure that is indexed by `Gen`?","files":null},{"type":5,"timestamp":1754568460,"nonce":"hBYA+Zh7lDgkwI3CosGOq5m+kEk=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOlL"},"added":["code: enhancement"],"removed":[]},{"type":5,"timestamp":1754568460,"nonce":"QMtbgUFgAkpxz73vDZC18O3ig6k=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOlz"},"added":["part: generators"],"removed":[]},{"type":5,"timestamp":1754568460,"nonce":"UvSKTW44ghCphFM+ddjmTk5Ge6E=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOmj"},"added":["status: feature request"],"removed":[]},{"type":5,"timestamp":1754568461,"nonce":"qylr7ofz+4OE+udTGRAludqoTSM=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOna"},"added":["issue: distribution"],"removed":[]},{"type":5,"timestamp":1754568461,"nonce":"L9gQcP37CRJ70Fx6618vcul1oUY=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOoB"},"added":["part: model coverage"],"removed":[]},{"type":5,"timestamp":1754568461,"nonce":"sR78JkqBDmdGdpaY+xHu5ok0pzg=","metadata":{"github-id":"LE_lADOEt7lWM7EtbHPzwAAAARuhOo1"},"added":["part: labels"],"removed":[]}]}