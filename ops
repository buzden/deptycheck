{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":1,"timestamp":1695721094,"nonce":"fXEzE9xYeLHoOcqcO561WMPGv9g=","metadata":{"github-id":"I_kwDOEt7lWM5yB8NE","github-url":"https://github.com/buzden/deptycheck/issues/88","origin":"github"},"title":"Consider given arguments and/or actual type arguments in the model coverage","message":"Currently labelling for the model coverage is automated by derivation mechanism for derived generators and by `withCoverage` macro for hand-written generators.\n\nCurrently if some type is used only as a given parameter (this happens for topmost generator and for arguments that are set by GADT and never claimed otherwise, say, never stored in any constructor of the type itself), it will be present in the model coverage report, but never will be marked as covered, even if it is actually used with an appropriate matter.\n\nThis can be done by calling a-la `withCoverage` for each of the given argument of the generator function. Also, we may need to consider left parts of the dependent pair of the returned value. Perhaps, the whole expressions of the type arguments should be considered too.\n\nThere will be some complications with `0`-arguments, as soon as we will support `Exists`-like dependent pairs as the generator's return type. I think, we will need to change the algorithm of potential model coverage collection to consider that some types may not be present in runtime, and thus are allowed to be not covered (unless, a runtime generator for this value is present). Surely, we need to be aware that the same type can be present both in an erased and runtime position, thus we need to take the runtime-most one state in a potential model coverage.","files":null}]}