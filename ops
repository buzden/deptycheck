{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":3,"timestamp":1709644458,"nonce":"msfn8Vk2lx68cpsP7xai2aAawqg=","metadata":{"github-id":"IC_kwDOEt7lWM518WFP","github-url":"https://github.com/buzden/deptycheck/issues/55#issuecomment-1978753359"},"message":"Just for a record, when you have the following data type definitions (based on the comment above)\n\n```idris\ndata X : Nat -\u003e Nat -\u003e Type where\n  MkX : X 42 m\n  MkX2 : X n m\n  MkX3 : X 42 24\n\ndata Y : Nat -\u003e Nat -\u003e Type where\n  MkY : Y n 1337\n\ndata Z : Type where\n  MkZ : (n : Nat) -\u003e (m : Nat) -\u003e X n m -\u003e Y n m -\u003e Z\n```\n\nhaving available the following (effective) generators\n\n```idris\ngenX : Fuel -\u003e Gen MaybeEmpty (n ** m ** X n m)\ngenXm : Fuel -\u003e (m : Nat) -\u003e Gen MaybeEmpty (n ** X n m)\ngenXnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (X n m)\n\ngenY : Fuel -\u003e Gen MaybeEmpty (n ** m ** Y n m)\ngenYn : Fuel -\u003e (n : Nat) -\u003e Gen MaybeEmpty (m ** Y n m)\ngenYnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (Y n m)\n```\n\ncurrently we derive generator for `Z` which is equivalent to the following variant (using simplicifaction hack):\n\n```idris\ngenZ : Fuel -\u003e Gen MaybeEmpty Z\ngenZ fl = do\n  (n ** m ** x) \u003c- genX fl\n  y \u003c- genYnm fl n m\n  pure $ MkZ n m x y\n```\n\nor, alternatively, this one\n\n```idris\ngenZ' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ' fl = do\n  (n ** m ** y) \u003c- genY fl\n  x \u003c- genXnm fl n m\n  pure $ MkZ n m x y\n```\n\nor alternative of both is simplification-hack option is turned off. _Notice, that technically derived code is not the same, but it is equivalent for this particular example._\n\nIf we tries to use most effective subgenerators for both `X` and `Y`, we would run into a chicken and egg problem:\n\n```idris\ngenZ'' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ'' fl = do\n  (m ** y) \u003c- genYn fl ?generated_below\n  (n ** x) \u003c- genXm fl m\n  pure $ MkZ n m x ?y's_n_does_not_unify\n```\n\n-----------------\n\nSo, what we could do is to employ the fusion. For this particular case, we can see than in the `MkZ` when using `X` and `Y` types, only two free variables are used, `n` and `m`, thus we can derive a fused data type indexed by them:\n\n```idris\ndata XY : (n : Nat) -\u003e (m : Nat) -\u003e Type where\n  MkX_MkY : XY 42 1337\n  MkX2_MkY : XY n 1337\n```\n\nIt contains a cartesian product of all the constructors that match each other (i.e. where actual indices unify with each other).\n\nAlso, we can derive the splitting function\n\n```idris\nsplitXY : XY n m -\u003e (X n m, Y n m)\nsplitXY MkX_MkY  = (MkX, MkY)\nsplitXY MkX2_MkY = (MkX2, MkY)\n```\n\nThus, we can call usual derivation for the fused type:\n\n```idris\ngenXY : Fuel -\u003e Gen MaybeEmpty (n ** m ** XY n m)\n```\n\nand derive the following generator for `Z`:\n\n```idris\ngenZ_ultimate : Fuel -\u003e Gen MaybeEmpty Z\ngenZ_ultimate fl = do\n  (n ** m ** xy) \u003c- genXY fl\n  let (x, y) = splitXY xy\n  pure $ MkZ n m x y\n```","files":null},{"type":6,"timestamp":1713267394,"nonce":"H9lM5g9e6l5a3DHYHxcGMys8bcA=","metadata":{"github-id":"UCE_lALOEt7lWM518WFPzkRNlRs"},"target":"fd6b76c11019682658fab3d7650327dc28e046e0fc72075445363b609d7e4d81","message":"Just for a record, when you have the following data type definitions (based on the comment above)\n\n```idris\ndata X : Nat -\u003e Nat -\u003e Type where\n  MkX : X 42 m\n  MkX2 : X n m\n  MkX3 : X 42 24\n\ndata Y : Nat -\u003e Nat -\u003e Type where\n  MkY : Y n 1337\n\ndata Z : Type where\n  MkZ : (n : Nat) -\u003e (m : Nat) -\u003e X n m -\u003e Y n m -\u003e Z\n```\n\nhaving available the following (effective) generators\n\n```idris\ngenX : Fuel -\u003e Gen MaybeEmpty (n ** m ** X n m)\ngenXm : Fuel -\u003e (m : Nat) -\u003e Gen MaybeEmpty (n ** X n m)\ngenXnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (X n m)\n\ngenY : Fuel -\u003e Gen MaybeEmpty (n ** m ** Y n m)\ngenYn : Fuel -\u003e (n : Nat) -\u003e Gen MaybeEmpty (m ** Y n m)\ngenYnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (Y n m)\n```\n\ncurrently we derive generator for `Z` which is equivalent to the following variant (using simplicifaction hack):\n\n```idris\ngenZ : Fuel -\u003e Gen MaybeEmpty Z\ngenZ fl = do\n  (n ** m ** x) \u003c- genX fl\n  y \u003c- genYnm fl n m\n  pure $ MkZ n m x y\n```\n\nor, alternatively, this one\n\n```idris\ngenZ' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ' fl = do\n  (n ** m ** y) \u003c- genY fl\n  x \u003c- genXnm fl n m\n  pure $ MkZ n m x y\n```\n\nor alternative of both is simplification-hack option is turned off. _Notice, that technically derived code is not the same, but it is equivalent for this particular example._\n\nIf we tries to use most effective subgenerators for both `X` and `Y`, we would run into a chicken and egg problem:\n\n```idris\ngenZ'' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ'' fl = do\n  (m ** y) \u003c- genYn fl ?generated_below\n  (n ** x) \u003c- genXm fl m\n  pure $ MkZ n m x ?y's_n_does_not_unify\n```\n\n-----------------\n\nSo, what we could do is to employ the fusion. For this particular case, we can see than in the `MkZ` when using `X` and `Y` types, only two free variables are used, `n` and `m`, thus we can derive a fused data type indexed by them:\n\n```idris\ndata XY : (n : Nat) -\u003e (m : Nat) -\u003e Type where\n  MkX_MkY : XY 42 1337\n  MkX2_MkY : XY n 1337\n```\n\nIt contains a cartesian product of all the constructors that match each other (i.e. where actual indices unify with each other).\n\nAlso, we can derive the splitting function\n\n```idris\nsplitXY : XY n m -\u003e (X n m, Y n m)\nsplitXY MkX_MkY  = (MkX {m=1337}, MkY {n=42})\nsplitXY (MkX2_MkY {n}) = (MkX2 {n} {m=1337}, MkY {n})\n```\n\nThus, we can call usual derivation for the fused type:\n\n```idris\ngenXY : Fuel -\u003e Gen MaybeEmpty (n ** m ** XY n m)\n```\n\nand derive the following generator for `Z`:\n\n```idris\ngenZ_ultimate : Fuel -\u003e Gen MaybeEmpty Z\ngenZ_ultimate fl = do\n  (n ** m ** xy) \u003c- genXY fl\n  let (x, y) = splitXY xy\n  pure $ MkZ n m x y\n```","files":null},{"type":6,"timestamp":1713267456,"nonce":"PHadKOzgdZ/FCpQ9NWnBd6Mvr/o=","metadata":{"github-id":"UCE_lALOEt7lWM518WFPzkRNmiA"},"target":"fd6b76c11019682658fab3d7650327dc28e046e0fc72075445363b609d7e4d81","message":"Just for a record, when you have the following data type definitions (based on the comment above)\n\n```idris\ndata X : Nat -\u003e Nat -\u003e Type where\n  MkX : X 42 m\n  MkX2 : X n m\n  MkX3 : X 42 24\n\ndata Y : Nat -\u003e Nat -\u003e Type where\n  MkY : Y n 1337\n\ndata Z : Type where\n  MkZ : (n : Nat) -\u003e (m : Nat) -\u003e X n m -\u003e Y n m -\u003e Z\n```\n\nhaving available the following (effective) generators\n\n```idris\ngenX : Fuel -\u003e Gen MaybeEmpty (n ** m ** X n m)\ngenXm : Fuel -\u003e (m : Nat) -\u003e Gen MaybeEmpty (n ** X n m)\ngenXnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (X n m)\n\ngenY : Fuel -\u003e Gen MaybeEmpty (n ** m ** Y n m)\ngenYn : Fuel -\u003e (n : Nat) -\u003e Gen MaybeEmpty (m ** Y n m)\ngenYnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (Y n m)\n```\n\ncurrently we derive generator for `Z` which is equivalent to the following variant (using simplicifaction hack):\n\n```idris\ngenZ : Fuel -\u003e Gen MaybeEmpty Z\ngenZ fl = do\n  (n ** m ** x) \u003c- genX fl\n  y \u003c- genYnm fl n m\n  pure $ MkZ n m x y\n```\n\nor, alternatively, this one\n\n```idris\ngenZ' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ' fl = do\n  (n ** m ** y) \u003c- genY fl\n  x \u003c- genXnm fl n m\n  pure $ MkZ n m x y\n```\n\nor alternative of both is simplification-hack option is turned off. _Notice, that technically derived code is not the same, but it is equivalent for this particular example._\n\nIf we tries to use most effective subgenerators for both `X` and `Y`, we would run into a chicken and egg problem:\n\n```idris\ngenZ'' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ'' fl = do\n  (m ** y) \u003c- genYn fl ?generated_below\n  (n ** x) \u003c- genXm fl m\n  pure $ MkZ n m x ?y's_n_does_not_unify\n```\n\n-----------------\n\nSo, what we could do is to employ the fusion. For this particular case, we can see than in the `MkZ` when using `X` and `Y` types, only two free variables are used, `n` and `m`, thus we can derive a fused data type indexed by them:\n\n```idris\ndata XY : (n : Nat) -\u003e (m : Nat) -\u003e Type where\n  MkX_MkY : XY 42 1337\n  MkX2_MkY : XY n 1337\n```\n\nIt contains a cartesian product of all the constructors that match each other (i.e. where actual indices unify with each other).\n\nAlso, we can derive the splitting function\n\n```idris\nsplitXY : XY n m -\u003e (X n m, Y n m)\nsplitXY MkX_MkY        = (MkX {m=1337}, MkY {n=42})\nsplitXY (MkX2_MkY {n}) = (MkX2 {n} {m=1337}, MkY {n})\n```\n\nThus, we can call usual derivation for the fused type:\n\n```idris\ngenXY : Fuel -\u003e Gen MaybeEmpty (n ** m ** XY n m)\n```\n\nand derive the following generator for `Z`:\n\n```idris\ngenZ_ultimate : Fuel -\u003e Gen MaybeEmpty Z\ngenZ_ultimate fl = do\n  (n ** m ** xy) \u003c- genXY fl\n  let (x, y) = splitXY xy\n  pure $ MkZ n m x y\n```","files":null},{"type":6,"timestamp":1713267484,"nonce":"XG8iX9IRwHdzVQIus+AkiocW49U=","metadata":{"github-id":"UCE_lALOEt7lWM518WFPzkRNnGQ"},"target":"fd6b76c11019682658fab3d7650327dc28e046e0fc72075445363b609d7e4d81","message":"Just for a record, when you have the following data type definitions (based on the comment above)\n\n```idris\ndata X : Nat -\u003e Nat -\u003e Type where\n  MkX : X 42 m\n  MkX2 : X n m\n  MkX3 : X 42 24\n\ndata Y : Nat -\u003e Nat -\u003e Type where\n  MkY : Y n 1337\n\ndata Z : Type where\n  MkZ : (n : Nat) -\u003e (m : Nat) -\u003e X n m -\u003e Y n m -\u003e Z\n```\n\nhaving available the following (effective) generators\n\n```idris\ngenX : Fuel -\u003e Gen MaybeEmpty (n ** m ** X n m)\ngenXm : Fuel -\u003e (m : Nat) -\u003e Gen MaybeEmpty (n ** X n m)\ngenXnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (X n m)\n\ngenY : Fuel -\u003e Gen MaybeEmpty (n ** m ** Y n m)\ngenYn : Fuel -\u003e (n : Nat) -\u003e Gen MaybeEmpty (m ** Y n m)\ngenYnm : Fuel -\u003e (n, m : Nat) -\u003e Gen MaybeEmpty (Y n m)\n```\n\ncurrently we derive generator for `Z` which is equivalent to the following variant (using simplicifaction hack):\n\n```idris\ngenZ : Fuel -\u003e Gen MaybeEmpty Z\ngenZ fl = do\n  (n ** m ** x) \u003c- genX fl\n  y \u003c- genYnm fl n m\n  pure $ MkZ n m x y\n```\n\nor, alternatively, this one\n\n```idris\ngenZ' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ' fl = do\n  (n ** m ** y) \u003c- genY fl\n  x \u003c- genXnm fl n m\n  pure $ MkZ n m x y\n```\n\nor alternative of both is simplification-hack option is turned off. _Notice, that technically derived code is not the same, but it is equivalent for this particular example._\n\nIf we tries to use most effective subgenerators for both `X` and `Y`, we would run into a chicken and egg problem:\n\n```idris\ngenZ'' : Fuel -\u003e Gen MaybeEmpty Z\ngenZ'' fl = do\n  (m ** y) \u003c- genYn fl ?generated_below\n  (n ** x) \u003c- genXm fl m\n  pure $ MkZ n m x ?y's_n_does_not_unify\n```\n\n-----------------\n\nSo, what we could do is to employ the fusion. For this particular case, we can see than in the `MkZ` when using `X` and `Y` types, only two free variables are used, `n` and `m`, thus we can derive a fused data type indexed by them:\n\n```idris\ndata XY : (n : Nat) -\u003e (m : Nat) -\u003e Type where\n  MkX_MkY : XY 42 1337\n  MkX2_MkY : XY n 1337\n```\n\nIt contains a cartesian product of all the constructors that match each other (i.e. where actual indices unify with each other).\n\nAlso, we can derive the splitting function\n\n```idris\nsplitXY : XY n m -\u003e (X n m, Y n m)\nsplitXY MkX_MkY        = (MkX {m=1337}     , MkY {n=42})\nsplitXY (MkX2_MkY {n}) = (MkX2 {n} {m=1337}, MkY {n})\n```\n\nThus, we can call usual derivation for the fused type:\n\n```idris\ngenXY : Fuel -\u003e Gen MaybeEmpty (n ** m ** XY n m)\n```\n\nand derive the following generator for `Z`:\n\n```idris\ngenZ_ultimate : Fuel -\u003e Gen MaybeEmpty Z\ngenZ_ultimate fl = do\n  (n ** m ** xy) \u003c- genXY fl\n  let (x, y) = splitXY xy\n  pure $ MkZ n m x y\n```","files":null},{"type":5,"timestamp":1711390755,"nonce":"7zFLxvjmisB9MvssYWBDi7ck+TE=","metadata":{"github-id":"LE_lADOEt7lWM5hR3UrzwAAAALZfGr9"},"added":["code: heuristics"],"removed":[]}]}