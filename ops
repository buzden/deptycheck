{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":5,"timestamp":1679919856,"nonce":"tvYWt8jgKUniniDs3cF3nMYQcig=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAAIPteIO"},"added":["part: derivation"],"removed":[]},{"type":5,"timestamp":1679919856,"nonce":"jWsNtBXHmQ7pLRSJSxQGBUYPZsM=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAAIPteIQ"},"added":["status: feature request"],"removed":[]},{"type":5,"timestamp":1679919856,"nonce":"QYQu9OW27W1Lkl2GPA3MQgrQr3M=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAAIPteIT"},"added":["issue: distribution"],"removed":[]},{"type":5,"timestamp":1679919856,"nonce":"iwVDIx09GSCOHmi1r5WJc5nsvrI=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAAIPteIU"},"added":["derive: core"],"removed":[]},{"type":5,"timestamp":1711390740,"nonce":"UZCBlxby+QusmhTREthXevY9A1U=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAALZfF9_"},"added":["code: heuristics"],"removed":[]},{"type":2,"timestamp":1723033273,"nonce":"fmkTgm/eeieAkOqcRk11H8FbM+Y=","metadata":{"github-id":"RTE_lADOEt7lWM5h3ypVzwAAAAM2Cykf"},"title":"Do not spend fuel when given index is structurally decreasing","was":"Do not spend fuel when given index is structurally decreasing"},{"type":3,"timestamp":1728382738,"nonce":"Bi3N5NOOqhgIQh4MPGPM8ZFCpi0=","metadata":{"github-id":"IC_kwDOEt7lWM6PBLFw","github-url":"https://github.com/buzden/deptycheck/issues/61#issuecomment-2399449456"},"message":"The main problem here (at least now) is preserving good (or even better) distribution. Consider `Fin n`: now it's evenly distibuted between values from `0` to left fuel (when left fuel is less than `n`). If we don't spend fuel, we cannot use it adequately fuel for frequency of recursive constructors (BTW, we seemingly cannot do this adequately when fuel is more than `n`).\n\nThe solution I see is having an interface returning max depth by given value and its indices, i.e. e.g. returning `n` by `{n : Nat} -\u003e Fin n`, and using this as a frequency measure in for types when it's implemented, and using (and spending) fuel as it is done now for other types.","files":null},{"type":5,"timestamp":1728382746,"nonce":"IBXY05XhoRQTJtkS1F6wodj1r2w=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAANjf1Ce"},"added":["status: discussion"],"removed":[]},{"type":3,"timestamp":1735135724,"nonce":"tB9afgux/Bmjby3NYDcO/TEIFVY=","metadata":{"github-id":"IC_kwDOEt7lWM6Ys5Iy","github-url":"https://github.com/buzden/deptycheck/issues/61#issuecomment-2561905202"},"message":"\u003e The solution I see is having an interface returning max depth by given value and its indices, i.e. e.g. returning `n` by `{n : Nat} -\u003e Fin n`, and using this as a frequency measure in for types when it's implemented, and using (and spending) fuel as it is done now for other types.\n\nImportant thing is that when in each variant there is only one subgenerator, we don't need an implementation of such an interface. Say, we have\n\n```idris\nimport Data.List.Quantifiers\n\ndata T = Leaf | Node (List T)\n\ndata NamedT : T -\u003e Type where\n  Leaf' : String -\u003e NamedT Leaf\n  Node' : Int -\u003e All NamedT xs -\u003e NamedT $ Node xs\n```\n\nyou don't need any distrubution tweaks for a generator of `NamedT` if you have `T` index being given.","files":null},{"type":3,"timestamp":1739802554,"nonce":"g10LCwgVPTmWAd5iJAcM6axoy54=","metadata":{"github-id":"IC_kwDOEt7lWM6evp8W","github-url":"https://github.com/buzden/deptycheck/issues/61#issuecomment-2663292694"},"message":"As an interim solution, we can do all this only in cases where indexation does by `Nat` value (and, probably, finishes only as zero). In this case, we can easily set nice local probabilities proportional to that `Nat` rather than a fuel value. Probabiy, we can get the minimal contant `Nat` from that index and subtract it from the current `Nat` to support ones basing on non-zeros","files":null},{"type":5,"timestamp":1739802629,"nonce":"G2xxcBySNDCfDP2IEluXy21JnWg=","metadata":{"github-id":"LE_lADOEt7lWM5h3ypVzwAAAAPNn2wp"},"added":["issue: performance"],"removed":[]},{"type":4,"timestamp":1744632222,"nonce":"tO2/vpQKA8GP5rFBdKWt9nwQ4D8=","metadata":{"github-id":"CE_lADOEt7lWM5h3ypVzwAAAAQECzA7"},"status":2}]}