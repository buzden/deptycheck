{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":5,"timestamp":1686731724,"nonce":"b2WQZ63e2pXli4FvsyMhN6axeOA=","metadata":{"github-id":"LE_lADOEt7lWM5omw_szwAAAAI3wfGv"},"added":["part: derivation"],"removed":[]},{"type":5,"timestamp":1686731724,"nonce":"YDB938vGxeU001RpJTuJAryHCWI=","metadata":{"github-id":"LE_lADOEt7lWM5omw_szwAAAAI3wfGz"},"added":["status: feature request"],"removed":[]},{"type":5,"timestamp":1686731915,"nonce":"o2s5YNVv/TTw/driahaRnkdwmVU=","metadata":{"github-id":"LE_lADOEt7lWM5omw_szwAAAAI3wm_O"},"added":["status: discussion"],"removed":[]},{"type":3,"timestamp":1686738305,"nonce":"+7bOAR74KvN6p1k9cVIQO8hDLkk=","metadata":{"github-id":"IC_kwDOEt7lWM5e05k7","github-url":"https://github.com/buzden/deptycheck/issues/74#issuecomment-1590925627"},"message":"It definitely is a necessary thing. And since I have already thought quite something about this problem a while ago, I'll try to summarise those thoughts here (not necessarily all at once).\n\n## Raw generators\n\nFirst of all, it looks like completeness proof of our current generators must *assume* completeness of raw generators.\n\nAlternatively, we can consider that this proof would be a variant of implication of completeness of some raw generators to a completeness of our generators, but this looks extremely hard since no raw generators are visible outside the type of a generator.\n\n## Type of the proof\n\n### Honest way\n\nIn the simplest form the completeness proof should look like *for this particular generator of type `a` for any value `x` of type `a` there is a way to get it from the generator. I call this *the honest form* of the completeness property.\n\nSince running of our generators involves a random seed, the realisation of the completeness property could look like this:\n\n```idris\n0 Complete : Gen a -\u003e Type\nComplete g = (x : a) -\u003e (seed ** runGen g seed = x)\n```\n\nif we had a function `runGen : Gen a -\u003e Seed -\u003e a`.\n\nOr at least the resulting type could be `(seed ** runGen g seed = Just x)` if the resulting type of `runGen` was `Maybe a`, considering that generators can be empty.\n\n### Generality problem\n\nThe problem is that our generators runner `unGen` is polymorphic of any `MonadRandom`, and thus if we could formulate a pure function like `runGen` above, it would mean that our property is formulated only for a particular pure `MonadRandom` implementation, like [random-pure](https://github.com/buzden/idris2-random-pure) which means that this completeness is not so complete.\n\nBut this is not the hardest problem.\n\n### Problems for pure\n\nEven if we would agree that our completeness property involves only particular pure `MonadRandom` implementation,\n*the honest form* would mean a bit more. It not only means that we theoretically can get any value of an appropriate type from a generator, it means that a series of pseudo-random values definitely can line up to provide any value. This property involves particular pseudo-random algorithm and particular way of using it, say, in `unGen` function. This variant of property is too intensional for our generators, it looks too deep into the implementation. Anyway, this is no feasible to try to build a reverse function for a realistic pseudo-random algorithm.\n\n### Proposed solution (discussible)\n\nSo, my idea was to abstract over implementation, assuming some reasonable properties for external stuff. Say, assuming that we can get any `Fin n` from any point of time in any `MonadRandom`, we can be sure that `OneOf` of complete generators is complete.\n\nHaving that, we can formulate a type for completeness property which describes each separate constructor of `Gen` type separately.\n\nSay, if `Gen a` is defined like\n\n```idris\ndata Gen : Type -\u003e Type where\n  Empty : Gen a\n  Pure : a -\u003e Gen a\n  Raw : (MonadRandom m =\u003e m a) -\u003e Gen a\n  OneOf : List (Gen a) -\u003e Gen a\n  Bind : Gen a -\u003e (a -\u003e Gen b) -\u003e Gen b\n```\n\nwe can consider the property in the following form:\n\n```idris\ndata Complete : Gen a -\u003e Type where\n  NoElems : Not a -\u003e Complete Empty\n  SingleElem : ((x, y : a) -\u003e x = y) -\u003e Complete $ Pure x\n  AssumeRaw : Complete $ Raw sf\n  Choose : Either (All Complete gs, ?composite_compl) -\u003e Complete $ OneOf gs\n  Chain : Complete lhs -\u003e ((x : a) -\u003e Complete $ rhs x) -\u003e Complete $ Bind lhs rhs\n```\n\n(we need to think what to write instead of `?composite_compl` to express a situation when `OneOf` of several non-complete generators produce a complete generator)\n\nHaving property in this form, we need several separate properties proving that, say `map` and `\u003c*\u003e` preserve completeness.\n\n### Further\n\nLike in #57 with emptiness characteristic, we can try to add completeness property to the type of `Gen` itself. Then, in any combinator there will be a need to think of when completeness is preserved or gained (which, I'm afraid, would blow signatures a lot).","files":null}]}