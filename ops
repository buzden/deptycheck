{"author":{"id":"b22b22cff7e1632a29cea99f31c0362d591fa721518f26c84cc60341fef126c0"},"ops":[{"type":1,"timestamp":1744212480,"nonce":"Dhj1Mg+74EM1Yd/6sOwuSUMw59A=","metadata":{"github-id":"I_kwDOEt7lWM6xz6hd","github-url":"https://github.com/buzden/deptycheck/issues/258","origin":"github"},"title":"Not optimal derivation order for `AllLTE`","message":"Consider the following example:\n```idris\ndata VectNat : Nat -\u003e Type where\n  Nil : VectNat Z\n  (::) : Nat -\u003e VectNat n -\u003e VectNat (S n)\n\ndata AllLTE : VectNat n -\u003e VectNat n -\u003e Type where\n  Base : AllLTE [] []\n  Step : LTE x y =\u003e\n         AllLTE xs ys -\u003e\n         AllLTE (x :: xs) (y :: ys)\n\ng : Fuel -\u003e\n    {n : _} -\u003e (l1, l2 : VectNat n) -\u003e\n    Gen MaybeEmpty $ AllLTE l1 l2\ng = deriveGen\n```\nLogging shows that `Step` is generated with not optimal order of its parameters. It would be much faster if it tried to generate `LTE` and only then went to the recursive path\n```\n[ build ] LOG deptycheck.derive.consBody:2: Spec.AllLTE[0(n), 1, 2] Step __ start __\n[ build ] LOG deptycheck.derive.least-effort:15: Spec.AllLTE[0(n), 1, 2] Step - determ: {#0 -\u003e \u003c=[] -\u003e[], #1 (ys) -\u003e \u003c=[] -\u003e[#0], #2 (xs) -\u003e \u003c=[] -\u003e[#0], #3 (y) -\u003e \u003c=[] -\u003e[], #4 (x) -\u003e \u003c=[] -\u003e[], #5 -\u003e \u003c=[] -\u003e[#3 (y), #4 (x)], #6 -\u003e \u003c=[] -\u003e[#0, #1 (ys), #2 (xs)]}\n[ build ] LOG deptycheck.derive.least-effort:15: Spec.AllLTE[0(n), 1, 2] Step - givs: [#0, #1 (ys), #2 (xs), #3 (y), #4 (x)]\n[ build ] LOG deptycheck.derive.least-effort:7: Spec.AllLTE[0(n), 1, 2] Step - used final order: [#6, #5]\n[ build ] LOG deptycheck.derive.closuring.internal:20: Spec.AllLTE[0(n), 1, 2] is used as an internal generator\n[ build ] LOG deptycheck.derive.closuring.internal:20: Data.Nat.LTE[0(n), 1(m)] is used as an internal generator\n[ build ] LOG deptycheck.derive.consBody:2: Spec.AllLTE[0(n), 1, 2] Step ^^  end  ^^\n```","files":null}]}