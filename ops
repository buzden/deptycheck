{"author":{"id":"c8b5e6f4594a39a69d740ff06f6530160b48ff53db7027c22c4091f811b01812"},"ops":[{"type":1,"timestamp":1694180873,"nonce":"dUTbPuWY3WF4NAMvxVdyc4QPMtU=","metadata":{"github-id":"I_kwDOEt7lWM5whHLg","github-url":"https://github.com/buzden/deptycheck/issues/81","origin":"github"},"title":"Use layered (staged) applicative composition at derivation to improve generation","message":"Monadic composition may be ineffective or make distribution bad is there a raw generator lies around. Thus, we can use applicative composition as much as we can in order to generate first values that we can.\n\nThus, at each moment inside generation we can see which values can be generated (i.e., which values do not depend on any other value which needs to be generated) and generate them in a single pass by composing appropriate generators applicatively. Then we can have the second round, because at this stage of generation some of values can be considered independent, because all values they depend on, are already present. And so on.\n\nThis should, by the way, reduce count of possible \"orderings\" (when calling for a particular data type constructor) which we suffer from currently.\n\nMy examples from thinking about this in May '23:\n\n```idris\nimport Test.DepTyCheck.Gen\n\ndata X : Type\n\ndata Y : Type\n\ndata F : Type\n\nfun : Y -\u003e F\n\ndata Z : Type\n\ndata B : X -\u003e F -\u003e Type\n\ndata C : X -\u003e Type\n\ndata D : Y -\u003e Type\n\ndata D' : Y -\u003e Type\n\ndata E : X -\u003e Z -\u003e Type\n\ndata T : Type where\n  MkA : (x : X) -\u003e (y : Y) -\u003e (z : Z) -\u003e B x (fun y) -\u003e C x -\u003e D y -\u003e D' y -\u003e E x z -\u003e T\n\ngenB_f : (f : F) -\u003e Gen (x ** B x f)\ngenB_xf : (x : X) -\u003e (f : F) -\u003e Gen (B x f)\n\ngenC : Gen (x ** C x)\ngenC_x : (x : _) -\u003e Gen (C x)\n\ngenD : Gen (y ** D y)\ngenD_y : (y : _) -\u003e Gen (D y)\n\ngenD' : Gen (y ** D' y)\ngenD'_y : (y : _) -\u003e Gen (D' y)\n\ngenE : Gen (x ** z ** E x z)\ngenE_x : (x : _) -\u003e Gen (z ** E x z)\n\ngenT : Gen T\ngenT = oneOf\n\n  [ -- (E + D) * (D' + B + C)\n    do ((x ** z ** e), (y ** d)) \u003c- (,) \u003c$\u003e genE \u003c*\u003e genD\n       (d', b, c) \u003c- (,,) \u003c$\u003e genD'_y y \u003c*\u003e genB_xf x (fun y) \u003c*\u003e genC_x x\n       pure $ MkA x y z b c d d' e\n\n  , -- D * (D' + B * (C + E))\n    do (y ** d) \u003c- genD\n       let l = genD'_y y\n       let r : Gen (x ** (B x (fun y), C x, (z ** E x z))) := do\n         (x ** b) \u003c- genB_f (fun y)\n         (c, (z ** e)) \u003c- (,) \u003c$\u003e genC_x x \u003c*\u003e genE_x x\n         pure (x ** (b, c, (z ** e)))\n       (d', (x ** (b, c, (z ** e)))) \u003c- (,) \u003c$\u003e l \u003c*\u003e r\n       pure $ MkA x y z b c d d' e\n\n  , -- (C + D) * (B + D' + E)\n    do ((x ** c), (y ** d)) \u003c- (,) \u003c$\u003e genC \u003c*\u003e genD\n       (b, d', (z ** e)) \u003c- (,,) \u003c$\u003e genB_xf x (fun y) \u003c*\u003e genD'_y y \u003c*\u003e genE_x x\n       pure $ MkA x y z b c d d' e\n\n  -- ... and other orders, say, D * (D' + C * (B + E)), (E + D') * (D + B + C)\n  ]\n```\n\nThis suspiciously resembles `Arrow`s composition, thus we may think (again) on 1) automation of arrows computation 2) representing generators as arrows.","files":null}]}