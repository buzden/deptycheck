1/2: Building Shared (Shared.idr)
2/2: Building Test (Test.idr)
LOG deptycheck.test.utils.specialise:0:  Expanded e: Test.Y {a = Prelude.Types.Nat} Test.Nn (Test.X Test.Nt (fromInteger 5) Test.Nn)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Task before normalisation: \ lam^0 => \ lam^1 => \ lam^2 => \ lam^3 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X lam^1 lam^2 lam^3)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] NormaliseTask returned: lambdaTy = (lam^0 : ({arg:1} : Prelude.Types.Nat) -> Prelude.Types.Nat) -> (lam^1 : ({arg:2} : Prelude.Types.Nat) -> Type) -> (lam^2 : Prelude.Types.Nat) -> (lam^3 : ({arg:3} : lam^1 lam^2) -> Prelude.Types.Nat) -> Type;
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2]                         lambdaBody = \ lam^0 => \ lam^1 => \ lam^2 => \ lam^3 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X lam^1 lam^2 lam^3);
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type name: Y^14421981371219706324.Y^14421981371219706324
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type not found, deriving...
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Derived Y^14421981371219706324.Y^14421981371219706324
LOG deptycheck.util.specialisation:10: Test.Y[0(a), 1, 2] Declared specialised type: Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X lam^1 lam^2 lam^3)
LOG deptycheck.test.utils.specialise:0: Y^14421981371219706324.Y^14421981371219706324[0(fv^lam^0), 1(fv^lam^1), 2(fv^lam^2), 3(fv^lam^3)] CallGen params: [Test.Nn, Test.Nt, fromInteger 5, Test.Nn]
LOG deptycheck.test.utils.specialise:0:  Expanded e: Test.Y {a = Prelude.Types.Nat} Test.Nn' (Test.X Data.Fin.Fin (fromInteger 5) Test.Nn')
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Task before normalisation: \ lam^0 => \ lam^1 => \ lam^2 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X Data.Fin.Fin lam^1 lam^2)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] NormaliseTask returned: lambdaTy = (lam^0 : ({arg:1} : Prelude.Types.Nat) -> Prelude.Types.Nat) -> (lam^1 : Prelude.Types.Nat) -> (lam^2 : ({arg:3} : Data.Fin.Fin lam^1) -> Prelude.Types.Nat) -> Type;
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2]                         lambdaBody = \ lam^0 => \ lam^1 => \ lam^2 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X Data.Fin.Fin lam^1 lam^2);
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type name: Y^17936145782101774282.Y^17936145782101774282
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type not found, deriving...
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Derived Y^17936145782101774282.Y^17936145782101774282
LOG deptycheck.util.specialisation:10: Test.Y[0(a), 1, 2] Declared specialised type: Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X Data.Fin.Fin lam^1 lam^2)
LOG deptycheck.test.utils.specialise:0: Y^17936145782101774282.Y^17936145782101774282[0(fv^lam^0), 1(fv^lam^1), 2(fv^lam^2)] CallGen params: [Test.Nn', fromInteger 5, Test.Nn']
