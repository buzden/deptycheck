1/2: Building Shared (Shared.idr)
2/2: Building Test (Test.idr)
LOG deptycheck.test.utils.specialise:0:  Expanded e: Test.Y {a = Prelude.Types.Nat} Test.Nn (Test.X Test.Nt (fromInteger 5) Test.Nn)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Task before normalisation: \ lam^0 => \ lam^1 => \ lam^2 => \ lam^3 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X lam^1 lam^2 lam^3)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] NormaliseTask returned: lambdaTy = (lam^0 : ({arg:1} : Prelude.Types.Nat) -> Prelude.Types.Nat) -> (lam^1 : ({arg:2} : Prelude.Types.Nat) -> Type) -> (lam^2 : Prelude.Types.Nat) -> (lam^3 : ({arg:3} : lam^1 lam^2) -> Prelude.Types.Nat) -> Type;
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2]                         lambdaBody = \ lam^0 => \ lam^1 => \ lam^2 => \ lam^3 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X lam^1 lam^2 lam^3);
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type name: Test.X1.X1
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type not found, deriving...
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Found or derived Test.X1.X1
LOG deptycheck.test.utils.specialise:0: Test.X1.X1[0(fv^lam^0), 1(fv^lam^1), 2(fv^lam^2), 3(fv^lam^3)] CallGen params: [Test.Nn, Test.Nt, fromInteger 5, Test.Nn]
LOG deptycheck.test.utils.specialise:0:  Expanded e: Test.Y {a = Prelude.Types.Nat} Test.Nn' (Test.X Data.Fin.Fin (fromInteger 5) Test.Nn')
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Task before normalisation: \ lam^0 => \ lam^1 => \ lam^2 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X Data.Fin.Fin lam^1 lam^2)
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] NormaliseTask returned: lambdaTy = (lam^0 : ({arg:1} : Prelude.Types.Nat) -> Prelude.Types.Nat) -> (lam^1 : Prelude.Types.Nat) -> (lam^2 : ({arg:3} : Data.Fin.Fin lam^1) -> Prelude.Types.Nat) -> Type;
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2]                         lambdaBody = \ lam^0 => \ lam^1 => \ lam^2 => Test.Y {a = Prelude.Types.Nat} lam^0 (Test.X Data.Fin.Fin lam^1 lam^2);
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type name: Test.X2.X2
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Specialised type not found, deriving...
LOG deptycheck.util.specialisation:20: Test.Y[0(a), 1, 2] Found or derived Test.X2.X2
LOG deptycheck.test.utils.specialise:0: Test.X2.X2[0(fv^lam^0), 1(fv^lam^1), 2(fv^lam^2)] CallGen params: [Test.Nn', fromInteger 5, Test.Nn']
