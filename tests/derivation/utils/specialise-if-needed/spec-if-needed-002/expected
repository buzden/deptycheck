1/2: Building Shared (Shared.idr)
2/2: Building Test (Test.idr)
LOG deptycheck.test.utils.specialise:0:  Expanded e: Test.X Prelude.Types.Nat Prelude.Types.S
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] Checking specialisation need for [Prelude.Types.Nat, Prelude.Types.S]...
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] (t := Prelude.Types.Nat) Given a type invocation w/o arguments, specialising
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] ({arg:1} := Prelude.Types.S) Given a non-type expr, passing through
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] Task before normalisation: \ lam^0 => Test.X Prelude.Types.Nat lam^0
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] NormaliseTask returned: lambdaTy = (lam^0 : ({arg:2} : Prelude.Types.Nat) -> Prelude.Types.Nat) -> Type;
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1]                         lambdaBody = \ lam^0 => Test.X Prelude.Types.Nat lam^0;
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] Specialised type name: X^17949373096448478648.X^17949373096448478648
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] Specialised type not found, deriving...
LOG deptycheck.util.specialisation:20: Test.X[0(t), 1] Derived Test.X^17949373096448478648.X^17949373096448478648
LOG deptycheck.util.specialisation:10: Test.X[0(t), 1] Declared specialised type Test.X^17949373096448478648.X^17949373096448478648: Test.X Prelude.Types.Nat lam^0
LOG deptycheck.test.utils.specialise:0: Test.X^17949373096448478648.X^17949373096448478648[0(fv^X^17949373096448478648.X^17949373096448478648^lam^0)] CallGen params: [Prelude.Types.S]
