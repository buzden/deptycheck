# Chapter 7: Recursive Type Handling

Welcome to Chapter 7! In [Chapter 6: Deep Constructor Analysis](06_deep_constructor_analysis_.md), we explored how DepTyCheck analyzes nested type structures like an archaeologist uncovering layers of ancient ruins. Now imagine building towers with toy blocks ðŸ—ï¸ðŸ§±. If you don't set building limits, you might try making a tower taller than your ceiling! DepTyCheck's **Recursive Type Handling** works similarlyâ€”it uses "fuel" to safely control recursions while generating data. Think of it like a construction crane that only extends to permitted heights! ðŸ—ï¸â›½

## Why Do We Need Recursion Control?

Imagine making a family tree:
```idris
data Person = Parent String (List Person)
```

This type definition is **recursive** because a `Person` contains other `Person`s. Without controls, a generator might try to create:
1. A parent â†’ 
2. With two children â†’ 
3. Each with two children â†’ 
4. and on forever!

We need safety limits, just like construction rules prevent cranes from extending beyond safe heights:

```mermaid
graph TB
    A[Crane at ground] --> B[Extends to level 1]
    B --> C[Extends to level 2]
    C --> D[Stops at level 3 - Fuel limit]
```

## Fuel: Your Safety Control

**Fuel** is a simple counter that tracks how deep we can generate recursively. It works like this:

```idris
data Fuel = Dry | More Fuel  -- More == Worth one deeper step

personGen : Fuel -> Gen Person
personGen Dry      = stop  -- Fuel empty: stop recursing
personGen (More f) = ...   -- Generate one level using fuel `f`
```

Each recursive step consumes one fuel unit. When we run out, DepTyCheck stops the recursionâ€”just like a crane stops extending when it reaches its maximum permit!

## Beginner's Example: Family Tree Generator

Let's create a simple person generator:

```idris
data Person = Parent String (List Person)

personGen : Fuel -> Gen Person
personGen fuel = case fuel of
  Dry      => elements [Parent "Ancestor" []]  -- Base case
  More f => do 
    name   <- randomName
    numKids <- choose (0, 2)
    kids  <- listOf numKids (personGen f)  -- Use fuel!
    pure $ Parent name kids
```

When we run `personGen (More (More Dry))`:
1. Parent "Mommy" generates â†’
2. Up to 2 children (possible) â†’
3. *But* each child can't have grandchildren (fuel exhausted)

Outputs:
```idris
[ Parent "Mommy" []
, Parent "Mommy" 
    [Parent "Child" []]
, Parent "Dad" 
    [Parent "Son" [], Parent "Daughter" []] 
]
```

## How the Crane Extends Safely

Imagine DepTyCheck as a crane operator building your tree:

```mermaid
sequenceDiagram
    Crane->>FuelTank: Request fuel (start)
    FuelTank-->>Crane: More fuel level 3
    Crane->>Crane: Generate Parent "Mommy"
    Crane->>Child1: Generate with fuel level 2
    Child1->>Grandchild: Try fuel level 1 (blocked later)
    Crane->>Child2: Generate with fuel level 2
    Grandchild-->>Child1: Returns empty 
    Child1-->>Crane: Returns [Parent "Child" []]
    Crane-->>You: Final Parent with children
```

## Inside the Fuel Mechanism

Let's look at simplified code from `src/Deriving/DepTyCheck/Gen/ConsRecs.idr`:

```idris
leftDepth : Fuel -> Nat1
leftDepth Dry      = 1    -- Base level when out of fuel
leftDepth (More f) = succ (leftDepth f)  -- Recursive step

personGen : Fuel -> Gen Person
personGen fuel = do
  depthLeft = leftDepth fuel  -- Calculate remaining steps
  ...
  when (depthLeft > 1) $ do
    -- Generate children if fuel permits
```

Key variables:
- `leftDepth`: How many levels remain
- `succ`: Increments the depth counter after each level

## Real-World Example: Directory Tree

Generate filesystem directories recursively:

```idris
data FileItem = 
    File String 
  | Dir String (List FileItem)

dirGen : Fuel -> Gen FileItem
dirGen fuel = case fuel of
  Dry => elements [File "readme.txt"]
  More f => oneOf
    [ File <$> filenameGen
    , Dir  <$> dirnameGen 
           <*> listOf f (dirGen f)  -- Use fuel for nested
    ]

-- Sample output with 2 fuel:
[ File "log.txt"
, Dir "Photos" [File "pic1.jpg", File "pic2.jpg"]
]
```

See how:
1. `photos` directory can't nest deeper dirs (fuel limits)
2. `File` values appear at all depths

## Your Recursion Safety SystemðŸ”’

Congratulations! You now understand DepTyCheck's recursion control:
- **Recursive types** can cause infinite generation loops
- **Fuel** restricts recursion depth like crane height limits
- Each `More fuel` step enables one more recursion level
- Safety mechanisms in `ConsRecs.idr` control the process

Just like construction crews work safely with height limits, DepTyCheck works safely with recursion limits!

Ready to explore how DepTyCheck manages impossible-to-generate cases? Next in [Chapter 8: Emptiness Tracking](08_emptiness_tracking_.md), we'll learn how DepTyCheck avoids "empty" generators where valid data can't be produced! ðŸš«ðŸ“¦

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)